var path = require("path");
var Oplog = require("./oplog.js");
var fs = require("fs");

module.exports = class Restore {
    constructor(config) {
        this.config = config;
    }

    getBackupFolder() {
        return this.config.getBackupDir();
    }

    // Given a directory of oplog dumps generated by the backup feature,
    // iteratively mongorestore them.
    // Mongorestore <3.4 expects a file named oplog.bson the directory specified
    // Mongorestore 3.4 adds support for --oplogFile parameter, which simplifies things.
    restore_oplogs(dir, options = {}) {
        let default_restore_args = ['--stopOnError', '--oplogReplay'];
        let oplog_start_at;
        let oplog_limit;
        if (this.config.options.noIndexRestore) {
            default_restore_args.push('--noIndexRestore')
        }
        if (options['oplogLimit']) {
            default_restore_args.push('--oplogLimit', options['oplogLimit']);
            oplog_limit = options['oplogLimit'];
        }

        if (this.config.options['oplogStartAt']) {
            oplog_start_at = timestamp.from_string(this.config.options['oplogStartAt']);
        }

        const source_files = Oplog.find_oplogs(dir);
        this.validate_continuity(source_files);
        console.log("Starting oplog restore...");

        source_files.forEach(filename=> {
            // TODO: mongorestore 3.4 supports --oplogFile

            if (oplog_start_at) {
                const timestamps = Oplog.timestamps_from_filename(filename);
                if (timestamps[timestamps.length - 1] <= oplog_start_at) {
                    console.log("Skipping batch: #{filename}. Last op in batch (ts: #{timestamps[:last]}) is before oplogStartAt: #{oplog_start_at}");
                    return;
                }
            }

            if (oplog_limit) {
                const timestamps = Oplog.timestamps_from_filename(filename);
                if (timestamps[0] > oplog_limit) {
                    console.log("Skipping batch: #{filename}. First op in batch (ts: #{timestamps[:first]}) is after oplogLimit: #{oplog_limit}");
                    return;
                }
            }

            const temp_file_path = Restore.create_temp_oplog_dir(dir, filename);
            const oplog_dir_path = path.dirname(temp_file_path);

            const restore_args = default_restore_args; //????.dup;
            if (Oplog.gzip_fingerprint(filename)) {
                restore_args.push('--gzip');
            }
            restore_args.push(oplog_dir_path);
            const status = this.config.mongorestore(restore_args).status;
            if (status != 0) {
                console.error("Mongorestore failed during oplog restore. Aborting. Exit code: #{status}");
                throw Error('Oplog restore failed.');
            }

            try {
                fs.unlinkSync(temp_file_path);
                fs.rmdirSync(oplog_dir_path);
            } catch (err) {
                console.error("Clean-up error for '#{temp_file_path}. #{e.message}");
                throw err;
            }
        });
        console.log("Oplog restore complete.");
    }

    restore_dump(dir) {
        const restore_args = ['--stopOnError'];
        if (this.config.options.noIndexRestore) {
            restore_args.push('--noIndexRestore');
        }
        if (this.config.useCompression) {
            restore_args.push('--gzip');
        }
        restore_args.push(path.join(dir, 'dump'));

        console.log("Starting full restore...");
        let status = this.config.mongorestore(restore_args).status;
        if (status != 0) {
            console.error("Mongorestore failed.");
            throw Error('Full restore failed.');
        }
        console.log("Full restore complete.")
    }

    perform(mode, options = {}) {
        if (options['oplogLimit']) {
            if (options['oplogLimit'].match(/\A\d+(?::\d+)?\z/)) {
                throw Error("oplogLimit is not a timestamp: eg. <seconds>[:ordinal]");
            }
        }

        if (mode == 'oplog') {
            this.restore_oplogs(this.getBackupFolder(), options);
        }
        else if (mode == 'full') {
            this.restore_dump(this.getBackupFolder(), options);
            this.restore_oplogs(this.getBackupFolder(), options);
        }
    }

    //Check for gaps in timestamps based only on the filename, trusting that the oplog set is complete (ie. the filename timestamps match the actual data)
    validate_continuity(source_files) {
        let expected_first = null;
        console.log("Checking timestamps...");
        source_files.forEach(filename => {
            let timestamps = Oplog.timestamps_from_filename(filename);
            if (!timestamps) {
                throw Error("Filename without timestamps found in restore set: #{filename}");
            }
            if (expected_first && expected_first != timestamps[0]) {
                throw Error("Missing oplog dump? Expected a filename with first timestamp '#{expected_first}', but got '#{timestamps[:first]}' from filename '#{filename}'.");
            }
            //expected_first = timestamps[:last]
            expected_first = timestamps[timestamps.length - 1];
        });
        return true;
    }

    static create_temp_oplog_dir(dir, filename) {
        let temp_dir = path.join(dir, 'tmp-restore', path.basename(filename));
        let temp_file_path = path.join(temp_dir, 'oplog.bson');
        fs.mkdirSync(temp_dir);
        fs.linkSync(filename, temp_file_path);
        return temp_file_path;
        /*rescue Errno::EEXIST => e
         # Probably, 'new_name' already exists when creating link.
         MongoOplogBackup.log.warn("Temporary oplog.bson link already exists: #{e.message}. Assuming valid.")
         return temp_file_path
         rescue SystemCallError => e
         console.error(("Setup error for oplog '#{filename}' in '#{temp_file_path}")
         raise
         }*/
    }
};