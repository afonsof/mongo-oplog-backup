let path = require('path');
let Oplog = require('./oplog');
let timestamp = require('./timestamp');
let fs = require('fs');

module.exports = class Restore {
    constructor(config) {
        this.config = config;
    }

    getBackupFolder() {
        return this.config.getBackupDir();
    }

    // Given a directory of oplog dumps generated by the backup feature,
    // iteratively mongorestore them.
    // Mongorestore <3.4 expects a file named oplog.bson the directory specified
    // Mongorestore 3.4 adds support for --oplogFile parameter, which simplifies things.
    restoreOplogs(dir, options = {}) {
        let defaultRestoreArgs = ['--stopOnError', '--oplogReplay'];
        let oplogStartAt;
        let oplogLimit;
        if (this.config.options.noIndexRestore) {
            defaultRestoreArgs.push('--noIndexRestore');
        }
        if (options['oplogLimit']) {
            defaultRestoreArgs.push('--oplogLimit', options['oplogLimit']);
            oplogLimit = options['oplogLimit'];
        }

        if (this.config.options['oplogStartAt']) {
            oplogStartAt = timestamp.fromString(this.config.options['oplogStartAt']);
        }

        const sourceFiles = Oplog.findOplogs(dir);
        this.validateContinuity(sourceFiles);
        console.log('Starting oplog restore...');

        return Promise.all(sourceFiles.map((sourceFile)=> {
            const filename = path.join(dir, sourceFile);

            if (oplogStartAt) {
                const timestamps = Oplog.timestampsFromFilename(filename);
                if (timestamps[timestamps.length - 1] <= oplogStartAt) {
                    console.log(`Skipping batch: ${filename}. Last op in batch ` +
                        `(ts: ${timestamps[timestamps.length - 1]}) is before ` +
                        `oplogStartAt: ${oplogStartAt}`);
                    return;
                }
            }

            if (oplogLimit) {
                const timestamps = Oplog.timestampsFromFilename(filename);
                if (timestamps[0] > oplogLimit) {
                    console.log(`Skipping batch: ${filename}. First op in batch ` +
                        `(ts: ${timestamps[0]}) is after oplogLimit: ${oplogLimit}`);
                    return;
                }
            }

            const tempFilePath = Restore.createTempOplogDir(dir, filename);
            const oplogDirPath = path.dirname(tempFilePath);

            const restoreArgs = defaultRestoreArgs;
            if (Oplog.gzipFingerprint(filename)) {
                restoreArgs.push('--gzip');
            }
            restoreArgs.push(oplogDirPath);
            return this.config
                .mongorestore(restoreArgs)
                .then((status)=> {
                    if (status != 0) {
                        console.error('Mongorestore failed during oplog restore. Aborting. Exit code: #{status}');
                        throw Error('Oplog restore failed.');
                    }

                    try {
                        fs.unlinkSync(tempFilePath);
                        fs.rmdirSync(oplogDirPath);
                    } catch (err) {
                        console.error(`Clean-up error for '${tempFilePath}. ${err.message}`);
                        throw err;
                    }
                    console.log('Oplog restore complete.');
                });
        }));
    }

    restoreDump(dir) {
        const restoreArgs = ['--stopOnError'];
        if (this.config.options.noIndexRestore) {
            restoreArgs.push('--noIndexRestore');
        }
        if (this.config.useCompression()) {
            restoreArgs.push('--gzip');
        }
        restoreArgs.push(path.join(dir, 'dump'));

        console.log('Starting full restore...');
        return this.config
            .mongorestore(restoreArgs)
            .then((status)=> {
                if (status != 0) {
                    console.error('Mongorestore failed.');
                    throw Error('Full restore failed.');
                }
                console.log('Full restore complete.');
            });
    }

    perform(mode, options = {}) {
        if (options['oplogLimit']) {
            if (options['oplogLimit'].match(/\A\d+(?::\d+)?\z/)) {
                throw Error('oplogLimit is not a timestamp: eg. <seconds>[:ordinal]');
            }
        }

        if (mode == 'oplog') {
            return this.restoreOplogs(this.getBackupFolder(), options);
        } else if (mode == 'full') {
            return this.restoreDump(this.getBackupFolder(), options).then(()=> {
                return this.restoreOplogs(this.getBackupFolder(), options);
            });
        }
    }

    // Check for gaps in timestamps based only on the filename, trusting that
    // the oplog set is complete (ie. the filename timestamps match the actual data)
    validateContinuity(sourceFiles) {
        let expectedFirst = null;
        console.log('Checking timestamps...');
        sourceFiles.forEach((filename) => {
            let timestamps = Oplog.timestampsFromFilename(filename);
            if (!timestamps) {
                throw Error('Filename without timestamps found in restore set: #{filename}');
            }
            if (expectedFirst && expectedFirst != timestamps[0]) {
                throw Error(`Missing oplog dump? Expected a filename with first timestamp '${expectedFirst}', ` +
                    `but got '${timestamps[0]}' from filename '${filename}'.`);
            }
            expectedFirst = timestamps[timestamps.length - 1];
        });
        return true;
    }

    static createTempOplogDir(dir, filename) {
        const tmpRestore = path.join(dir, 'tmp-restore');
        if (!fs.existsSync(tmpRestore)) {
            fs.mkdirSync(tmpRestore);
        }
        let tempDir = path.join(tmpRestore, path.basename(filename));
        let tempFilePath = path.join(tempDir, 'oplog.bson');

        if (fs.existsSync(tempFilePath)) {
            fs.unlinkSync(tempFilePath);
        }
        if (fs.existsSync(tempDir)) {
            fs.rmdirSync(tempDir);
        }
        fs.mkdirSync(tempDir);
        fs.linkSync(filename, tempFilePath);
        return tempFilePath;
    }
};
